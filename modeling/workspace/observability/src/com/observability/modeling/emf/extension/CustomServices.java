//**************************************************************************************************//
/* Observability Project
 * Copyright 2015 Master of Software Engineering team: Laila Alhmound, Ying (Joel) Gao, Caglayan (Gem) Gemici, Rajat Kapoor, Prasanth Nair, Varun Saravagi
 * Copyright 2015 Institute for Software Research | School of Computer Science | Carnegie Mellon University
 * Copyright 2015 Software Engineering Institute
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 */
//**************************************************************************************************//

package com.observability.modeling.emf.extension;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.util.List;





import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.ResourcesPlugin;

import com.observability.modeling.emf.*;

import org.eclipse.emf.ecore.EObject;

import com.observability.modeling.emf.DatabaseCluster;
import com.observability.modeling.emf.DbType;
import com.observability.modeling.emf.Element;
import com.observability.modeling.emf.EmfFactory;
import com.observability.modeling.emf.KeyValue;
import com.observability.modeling.emf.Metric;
import com.observability.modeling.emf.Model;
import com.observability.modeling.emf.NodeMachine;
import com.observability.modeling.probe.descriptor.DescriptorParserImpl;
import com.observability.modeling.probe.descriptor.entities.DbMetric;
import com.observability.modeling.probe.descriptor.entities.ElementTag;
import com.observability.modeling.probe.descriptor.entities.Machine;
import com.observability.modeling.probe.descriptor.entities.Scope;
import com.observability.modeling.probe.descriptor.entities.SystemMetric;

/**
 * @author gemici
 * This class is a service class that reads the probe descriptors and 
 * changes the EMF model instance according to the information on the descriptors
 */

public class CustomServices {
	
	/*
	 * The relative path to where the probe descriptors are stored
	 */
	private static String PROBE_DESCRIPTOR_DIR_PATH = "descriptors";
	
	/*
	 * In memory representation of the descriptor files. One dbType is created
	 * per descriptor file
	 */
	private static List<com.observability.modeling.probe.descriptor.entities.DbType> dbTypes = null;
	
	/*
	 * Factory class to manipulate the EMF model instance.
	 */
	private static EmfFactory factory = EmfFactory.eINSTANCE;
    
	
    /**
     * Parse the descriptors and bring the info into entities at class loading
     * This will search through all the projects in the current workspace for the descriptors dir.
     */
	
	public static void parseDescriptors(){
		 
		IProject[] projects =	ResourcesPlugin.getWorkspace().getRoot().getProjects();
		File descriptorDir = null;
		boolean descriptorDirFound = false;
		for (int i = 0; i < projects.length; i++) {
			descriptorDir = projects[i].getLocation().append(PROBE_DESCRIPTOR_DIR_PATH).toFile();
			if(Files.exists(descriptorDir.toPath() , LinkOption.NOFOLLOW_LINKS)){
				descriptorDirFound = true;
				break;
			}
		}
		if(descriptorDirFound)
			parseDescriptors(descriptorDir.toPath());
		else
			throw new RuntimeException("Cannot find descriptors. Please copy the descriptors in the 'descriptor' "
					+ "directory in the root of the project and create the file again."); 
			
    }
	
	 /**
     * Parse the descriptors and bring the info into entities at class loading
     * 
     * @param descriptorsPath the path to the dir where the descriptor files are located inside the project
     * TODO remove duplicate code.
     */
	public static void parseDescriptors(Path descriptorsPath){
		if(Files.exists(descriptorsPath , LinkOption.NOFOLLOW_LINKS)){
			// if descriptors exist, get the parsed descriptors
			DescriptorParserImpl parser = new DescriptorParserImpl(descriptorsPath);
			dbTypes = parser.parseDescriptors();
		}
		else {
			throw new RuntimeException("Cannot find descriptors. Please copy the descriptors in the 'descriptor' "
					+ "directory in the root of the project and create the file again."); 
		}
	}
	
	
	/**
	 * This method is called from the model creation wizard code which is 
	 * generated by EMF. It creates the dbTypes and metrics inside them on 
	 * the EMF instance (aka semantic model) by looking at the information loaded 
	 * from the descriptors.
	 * 
	 * @param model the root element to fill in the new entities
	 * @param dirPath 
	 */
	public static void initializeDbTypes( Model model, Path dirPath) {
		
		//Get the parsers
		parseDescriptors(dirPath.resolve(PROBE_DESCRIPTOR_DIR_PATH));
		
		//Create dbTypes for each descriptor file
		for (com.observability.modeling.probe.descriptor.entities.DbType dbType : dbTypes) {
			DbType newDbType = factory.createDbType();
			newDbType.setName(dbType.getName());
			
			createSystemMetricParameters(newDbType, dbType);
			createDbMetricParameters(newDbType, dbType);
			createAggregatedMetricParameters(newDbType, dbType);

			model.getAvailableDbTypes().add(newDbType);
		}
				    
		
	}
	/**
	 * Fill the Emf semantic instance with aggregatedMetric information from the parser.
	 * @param newDbType The emf dbType entity
	 * @param parsedDbType The parser generated dbType entity
	 */
	private static void createAggregatedMetricParameters(DbType newDbType, com.observability.modeling.probe.descriptor.entities.DbType  parsedDbType) {
		List<com.observability.modeling.probe.descriptor.entities.AggregatedMetric> aggMetrics  = parsedDbType.getAggregatedMetrics();
		for (com.observability.modeling.probe.descriptor.entities.AggregatedMetric aggMetric : aggMetrics) {
			
			//Create a db metric entry in semantic model
			AggregatedMetric metric = factory.createAggregatedMetric();
			
			metric.setName(aggMetric.getName());
			
			//Copy the element and sub elements and keyValues
			for(ElementTag element :aggMetric.getElements()){
				Element semanticElement = factory.createElement();
				semanticElement.setName(element.getName());
				semanticElement.setValue(element.getValue());
				fillElements(element, semanticElement);
				metric.getElements().add(semanticElement);

			}
			newDbType.getAvailableMetrics().add(metric);
			

		}
		
	}

	/**
	 * Fill the Emf semantic instance with database metric information from the parser.
	 * @param newDbType The emf dbType entity
	 * @param parsedDbType The parser generated dbType entity
	 */
	private static void createDbMetricParameters(DbType newDbType, com.observability.modeling.probe.descriptor.entities.DbType  parsedDbType) {
		List<DbMetric> dbMetrics  = parsedDbType.getDbMetrics();
		for (DbMetric dbMetric : dbMetrics) {
			
			//Create a db metric entry in semantic model
			BaseMetric metric = factory.createBaseMetric();
			metric.setType(dbMetric.getType().toString());
			metric.setName(dbMetric.getName());
			
			//Copy the element and sub elements and keyValues
			for(ElementTag element :dbMetric.getElements()){
				Element semanticElement = factory.createElement();
				semanticElement.setName(element.getName());
				semanticElement.setValue(element.getValue());
				fillElements(element, semanticElement);
				metric.getElements().add(semanticElement);

			}
			newDbType.getAvailableMetrics().add(metric);
			

		}
		
	}

	/**
	 * Fill the Emf semantic instance with system metric information from the parser.
	 * @param newDbType The emf dbType entity
	 * @param parsedDbType The parser generated dbType entity
	 */
	private static void createSystemMetricParameters(DbType newDbType, com.observability.modeling.probe.descriptor.entities.DbType  parsedDbType) {
		List<SystemMetric> systemMetrics  = parsedDbType.getSystemMetrics();
		for (SystemMetric systemMetric : systemMetrics) {
			
			//Create a system metric entry in semantic model
			BaseMetric metric = factory.createBaseMetric();
			metric.setType(systemMetric.getType().toString());
			metric.setName(systemMetric.getName());
			
			//Copy the element and sub elements and keyValues
			for(ElementTag element :systemMetric.getElements()){
				Element semanticElement = factory.createElement();
				semanticElement.setName(element.getName());
				semanticElement.setValue(element.getValue());
				
				fillElements(element, semanticElement);
				metric.getElements().add(semanticElement);
			}
			
			newDbType.getAvailableMetrics().add(metric);

		}
		
	}

	/**
	 * This method creates a new machine instance in the given cluster.
	 * It will populate the correct dynamic elements and key values according
	 * to the which dbType the cluster is associated with.
	 * 
	 * @param containerCluster the cluster the new machine is to be added
	 * @return false if operation fails,true otherwise
	 */
	public static boolean initializeMachine(EObject containerCluster){
		
		//parse only one time
		if(dbTypes == null)
			parseDescriptors();
		DatabaseCluster cluster = (DatabaseCluster) containerCluster;
		
		//If the cluster is not associated with a dbType do nothing
		DbType associatedDbType = cluster.getAssociatedDbType();
		if(associatedDbType == null)
			return false;
		
		NodeMachine machine = factory.createNodeMachine();
		
		//Copy elements from the entities filled from descriptor to EMF semantic instance
		for (com.observability.modeling.probe.descriptor.entities.DbType dbType : dbTypes) {
			if(dbType.getName().equals(associatedDbType.getName())){
				Machine machineParam = dbType.getMachine();
				
				fillElements( machineParam, machine);
				break;
			}
		}
		machine.setName("Machine " + (cluster.getMachines().size() + 1) + "");
		cluster.getMachines().add(machine);
		return true;
		
		
	}
	
	/**
	 * 
	 * @param machineParam 
	 * @param rootElement
	 */
	private static void fillElements(Machine machineParam, NodeMachine semanticMachine) {
		List<ElementTag> elementTags = machineParam.getElements();
		List<com.observability.modeling.probe.descriptor.entities.KeyValue> keyValues = machineParam.getKeyValues();
		
		for (ElementTag element : elementTags) {
			
			
			//Only add local scope elements when a new model instance is created
			//External scope elements will be added when a cluster is associated with a metric
			
			if(element.getScope().equals(Scope.LOCAL)){
				Element newElement = factory.createElement();
				
				//copy name and value
				newElement.setName(element.getName());
				newElement.setValue(element.getValue());
								
				//fill sub elements and key values
				fillElements(element, newElement);
				
				semanticMachine.getElements().add(newElement);
			}
			
		}
		
		// We assume key values at root level are local
		for (com.observability.modeling.probe.descriptor.entities.KeyValue keyValue: keyValues){
			KeyValue kV = factory.createKeyValue();
			kV.setKey(keyValue.getName());
			kV.setValue(keyValue.getValue());
			semanticMachine.getKeyValues().add(kV);
		}
		
	}
	
	/**
	 * Recursive method to copy the elements and keyValues
	 * given the starting node of the descriptor entities and EMF semantic model
	 * @param element  point to start copying from the descriptor entities 
	 * @param newElement point to start copying to the EMF semantic model
	 */
	private static void fillElements(ElementTag element, Element newElement) {
		
		//For each sub element copy them as well
		List<ElementTag> elements = element.getElements();
		if(elements.size() != 0){
			for (ElementTag elementTag : elements) {
				Element newSubElement = factory.createElement();
				fillElements(elementTag, newSubElement);
				newElement.getElements().add(newSubElement);
			}
		}
		
		//For each keyValue element copy them as well
		List<com.observability.modeling.probe.descriptor.entities.KeyValue> keyValues =  element.getKeyValues();
		if(keyValues.size() != 0){
			for (com.observability.modeling.probe.descriptor.entities.KeyValue keyValue : keyValues) {
				KeyValue newKey = factory.createKeyValue();
				newKey.setKey(keyValue.getName());
				newKey.setValue(keyValue.getValue());
				newElement.getKeyValues().add(newKey);
			} 
		}
	}
	/**
	 * Clear all nodes of a cluster and create noOfMachines
	 * number of new nodes with appropriate sub elements
	 * 
	 * TODO For now existing nodes are cleared. We should think
	 * about what to do to them
	 * @param databaseCluster cluster that new node machines will be added to
	 * @param noOfMachines number of machines to be created
	 */
	public static void createNodes(DatabaseCluster databaseCluster,
			int noOfMachines) {
		databaseCluster.getMachines().clear();
		for (int i = 0; i < noOfMachines; i++) {
			initializeMachine(databaseCluster);
			
		}
		
	}
	
	public static boolean addMetricSpecificParamsToMachine(EObject containerCluster){
		return true;
	}

	public CustomServices(){
		System.out.println("CustomServices ready!");
	}
	
	

}
